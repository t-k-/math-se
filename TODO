! build library path config 

! depth-by-depth identical path merging search

! posting file with incremented ID and skip-list merging search

! brword ID does not need a long HASH

! incrimination: one big doc is matching with a query, except for a proliferous branch word on one of its sub-tree. But we can find that doc using its another sub-tree, to better access the score, we need incrimination. 
* when a docID is in, all the brw with same docID in terms of the same path are also in.

! use READ instead of WRITE to open bdb when searching.

! [ use node with branch factor, to determine if tree are identical ]

! have a max/min info in posting file header.

! number each node in a tree for better debug

! ID belongs to level x, ordered by ID, score pruning: 
1) Score can be given to specific ID whenever all the relevant brword of that ID is fully get.
2) use simply sum of brw score for a given ID will help to prune 2 if we know final score of 1: final_score_2 < sum_score_2 < final_score_1

! limits log
---------------------
NTCIR data evalutation

~~~~~~~~~~~~~~~~~~~~~~
concurrent retrieval

remove [NULL] 

skip node in branchword: [

~~~~~~~~~~~~~~~~~~~~~
Provide a WEB interface like Symbol Lab

incorporation with general text search

Context search, search for web pages containing the most selected keywords (not only restricted to formula):
given keywords K1 AND K2 AND K3, with weights a1 a2 a3.
Do three times of separate search on each keywords, list results in three thread ordered by pageID:
thread1: 1 1 3 4 5 6 7 7 9
thread2: 1 2 3 4 8 9
thread3: 1 2 2 2 6 7 8
Then you get, for example, page with ID = 1 has a vector(2,1,1) and page with ID = 2 has a vector(0,1,3).
The final score of a page is given by, for example of page with ID=1: (2,1,1) * (a1,a2,a3)

NOT operation

provide instances for elastic search

\def\specialFrac#1#2{\frac{x + #1}{y + #2}} 整个网页有效，所以要用预处理
\DeclareMathOperator
\newcommand
\newenvironment
